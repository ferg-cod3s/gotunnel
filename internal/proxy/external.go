package proxy

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"
)

// External proxy implementations for nginx, caddy, etc.

// startNginxProxy configures and starts nginx proxy
func (m *Manager) startNginxProxy() error {
	if !commandExists("nginx") {
		return fmt.Errorf("nginx not found - install nginx or use --proxy=builtin")
	}

	fmt.Println("üîß Configuring nginx proxy...")
	return fmt.Errorf("nginx proxy not yet implemented - use --proxy=builtin for now")
}

// startCaddyProxy configures and starts caddy proxy  
func (m *Manager) startCaddyProxy() error {
	if !commandExists("caddy") {
		return fmt.Errorf("caddy not found - install caddy or use --proxy=builtin")
	}

	fmt.Println("üîß Configuring caddy proxy...")
	return fmt.Errorf("caddy proxy not yet implemented - use --proxy=builtin for now")
}

// generateConfigFiles generates configuration for external proxies
func (m *Manager) generateConfigFiles() error {
	fmt.Println("üìù Generating proxy configuration files...")

	if err := m.generateNginxConfig(); err != nil {
		fmt.Printf("‚ö†Ô∏è  Failed to generate nginx config: %v\n", err)
	}

	if err := m.generateCaddyConfig(); err != nil {
		fmt.Printf("‚ö†Ô∏è  Failed to generate caddy config: %v\n", err)
	}

	return nil
}

// generateNginxConfig creates nginx configuration for current routes
func (m *Manager) generateNginxConfig() error {
	const nginxTemplate = `# Generated by gotunnel
# Add this to your nginx configuration

{{range $domain, $route := .Routes}}
server {
    listen 80;
    server_name {{$domain}};
    
    location / {
        proxy_pass http://{{$route.TargetHost}}:{{$route.TargetPort}};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

{{if $route.HTTPS}}
server {
    listen 443 ssl;
    server_name {{$domain}};
    
    # SSL configuration (you'll need to configure certificates)
    # ssl_certificate /path/to/{{$domain}}.crt;
    # ssl_certificate_key /path/to/{{$domain}}.key;
    
    location / {
        proxy_pass https://{{$route.TargetHost}}:{{$route.TargetPort}};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
{{end}}

{{end}}
`

	tmpl, err := template.New("nginx").Parse(nginxTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse nginx template: %w", err)
	}

	// Get config directory
	configDir, err := os.UserConfigDir()
	if err != nil {
		configDir = os.TempDir()
	}
	gotunnelDir := filepath.Join(configDir, "gotunnel")
	if err := os.MkdirAll(gotunnelDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Create nginx config file
	configFile := filepath.Join(gotunnelDir, "nginx.conf")
	file, err := os.Create(configFile)
	if err != nil {
		return fmt.Errorf("failed to create nginx config file: %w", err)
	}
	defer file.Close()

	// Execute template
	data := struct {
		Routes map[string]*Route
	}{
		Routes: m.routes,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute nginx template: %w", err)
	}

	fmt.Printf("üìù Generated nginx config: %s\n", configFile)
	fmt.Printf("üí° Add this to your nginx configuration:\n")
	fmt.Printf("   include %s;\n", configFile)
	fmt.Printf("   sudo nginx -s reload\n\n")

	return nil
}

// generateCaddyConfig creates caddy configuration for current routes  
func (m *Manager) generateCaddyConfig() error {
	const caddyTemplate = `# Generated by gotunnel
# Add this to your Caddyfile

{{range $domain, $route := .Routes}}
{{$domain}} {
    reverse_proxy {{$route.TargetHost}}:{{$route.TargetPort}}
}

{{end}}
`

	tmpl, err := template.New("caddy").Parse(caddyTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse caddy template: %w", err)
	}

	// Get config directory
	configDir, err := os.UserConfigDir()
	if err != nil {
		configDir = os.TempDir()
	}
	gotunnelDir := filepath.Join(configDir, "gotunnel")
	if err := os.MkdirAll(gotunnelDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Create caddy config file
	configFile := filepath.Join(gotunnelDir, "Caddyfile")
	file, err := os.Create(configFile)
	if err != nil {
		return fmt.Errorf("failed to create caddy config file: %w", err)
	}
	defer file.Close()

	// Execute template
	data := struct {
		Routes map[string]*Route
	}{
		Routes: m.routes,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute caddy template: %w", err)
	}

	fmt.Printf("üìù Generated caddy config: %s\n", configFile)
	fmt.Printf("üí° Add this to your Caddyfile or run:\n")
	fmt.Printf("   caddy run --config %s\n\n", configFile)

	return nil
}

// reloadNginx reloads nginx configuration
func reloadNginx() error {
	if !commandExists("nginx") {
		return fmt.Errorf("nginx not found")
	}

	cmd := exec.Command("nginx", "-s", "reload")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to reload nginx: %w", err)
	}

	return nil
}

// reloadCaddy reloads caddy configuration  
func reloadCaddy() error {
	if !commandExists("caddy") {
		return fmt.Errorf("caddy not found")
	}

	cmd := exec.Command("caddy", "reload")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to reload caddy: %w", err)
	}

	return nil
}